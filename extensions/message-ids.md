---
title: IRCv3 Message IDs
layout: spec
work-in-progress: true
copyrights:
  -
    name: "James Wheare"
    period: 2016
    email: "james@irccloud.com"
---

## Notes for implementing work-in-progress version

This is a work-in-progress specification.

Software implementing this work-in-progress specification MUST NOT use the
unprefixed `msgid` tag name. Instead, implementations SHOULD use
the `draft/msgid` tag name to be interoperable with other software
implementing a compatible work-in-progress version.

The final version of the specification will use an unprefixed tag name.

## Introduction

This specification describes a mesage tag indicating a server supplied unique ID for `PRIVMSG` and `NOTICE` messages.

## Motivation

Communication on IRC has historically been limited to a flat structure of sequential messages without unique identifiers shared across clients. As a result, the protocol lacks an ability to establish relationships between messages and other entities. This places limits on client-side enhancements such as reply tracking, message editing, rating or sending other forms of message annotation.

The message ID tag is a way for servers to enable these enhancements.

## Architecture

### Dependencies

The `draft/message-tags` capability MUST be negotiated for servers wishing to use this tag.

### Tags

This specification adds the `draft/msgid` tag, which has one required value.

This tag MAY be sent by a server on `PRIVMSG` and `NOTICE` messages.

#### Tag value

The tag value is chosen by the originating server and MUST be unique, meaning any other message transmitted on the entire network at any time MUST NOT share the same value.

However, if a message is re-transmitted as-is, for example with the [`chathistory`](./batch/chathistory-3.3.html) batch type, the ID SHOULD be reused. As a result, clients MUST accept shared IDs.

The tag value MUST be treated as a case sensitive opaque identifier. Clients MUST NOT use case folding or normalization when comparing IDs.

## Server implementation considerations

This section is non-normative.

In order to guarantee sufficient uniqueness, message IDs can't be implemented as simple numeric counters that risk clashing with other servers on the network, or being reset if the server restarts.

Some examples of appropriate IDs are:

* An [RFC 4122 UUID](https://tools.ietf.org/html/rfc4122)
* An ID generated by a shared external provider, used by all servers on the network
* A numeric counter, prefixed with a server ID, with the latest value saved externally to the IRCd on every issue, to allow for power failures.
* A numeric counter, prefixed with a server ID as well as the server startup timestamp at a suitable precision.

When using timestamps, make sure they're correctly synchronised using NTP or similar.

Although clients are required to treat IDs as case sensitive opaque values, servers might still choose a case insensitive ID format internally.

### Choosing an ID format

Certain message ID formats could present a length issue if other tags are being used. The trade-offs between length and complexity of implementation should be carefully considered when choosing an ID format.

For instance, a UUID in hex form takes up 32 bytes (or 22 bytes in unpadded base64), and hasÂ widely available standardised implementations in many languages and no external dependencies. Conversely, a custom format can be much shorter, and might depend on an external service, disk I/O, additional state being tracked by the server, or untested proprietary code. 

If the 512-byte tag limit is only being sparsely used overall, the simpler and longer format might be chosen. But if the server's capabilities put messages at a greater risk of reaching the limit, a shorter custom format might be more suitable.

Another consideration is the chance of collisions. For example, some versions and implementations of the UUID specification rely on conditions that may not always produce collision-free outputs. However, if the probability is sufficiently low, a "practical" (if not guaranteed) uniqueness might be acceptable, given the requirement on clients to accept shared IDs.

## Client implementation considerations

This section is non-normative.

Message IDs have no guarantee of being universally unique across different IRC networks, nor will they necessarily share the same format. There is also no requirement that numeric IDs increase monotonically. Don't attempt to correlate them beyond their scope and don't use them for message ordering.

In the case of re-transmitted messages that share an ID, clients might choose to mark a message as repeated, or just use the most recent occurence as the target for followup actions. Using server IDs alone as internal primary keys isn't recommended, otherwise re-transmitted messages may not individually addressable in client-side message stores.

Handling duplicates gracefully is also useful in the case of IDs that have a chance of collision.

## Examples

This section is non-normative, message IDs are not required to be UUIDs or have any specific format. Additional tags used in these examples may or may not have a specified meaning elsewhere.

A channel `PRIVMSG` sent by the server:

    S: @draft/msgid=63E1033A051D4B41B1AB1FA3CF4B243E :nick!user@host PRIVMSG #channel :Hello!

A private `PRIVMSG` sent by the server:

    S: @draft/msgid=server1-1480339715754191-21 :nick!user@host PRIVMSG me :Hello!

A channel `NOTICE` sent by the server:

    S: @draft/msgid=G6PuDDBWQYmu3HmXXOAPzA :nick!user@host NOTICE #channel :Hello!

A private `NOTICE` sent by the server:

    S: @draft/msgid=ticketid-5 :nick!user@host NOTICE me :Hello!

A channel `PRIVMSG` sent by the server, and a possible client response. The `+example/reply` tag is a non-standard example:

    S: @draft/msgid=msgid1 :nick!user@host PRIVMSG #channel :Hello!
    C: @+example/reply=msgid1 :nick2!user2@host2 PRIVMSG #channel :Hello to you!

Two channel `PRIVMSG` messages sent by the server, with possible non-standard example annotations to indicate split message concatenation:

    S: @draft/msgid=msgid1;example/split :nick!user@host PRIVMSG #channel :Hello
    S: @draft/msgid=msgid2;example/concat=msgid1 :nick!user@host PRIVMSG #channel : World

A client negotiating the `draft/message-tags` capability to enable and disable messages tagged with IDs.

    S: :nick!user@host PRIVMSG #channel :Hello
    C: CAP REQ draft/message-tags
    S: :irc.example.com CAP me ACK :draft/message-tags
    S: @draft/msgid=msgid-a :nick!user@host PRIVMSG #channel :Hello again
    C: CAP REQ -draft/message-tags
    S: :irc.example.com CAP me ACK :-draft/message-tags
    S: :nick!user@host PRIVMSG #channel :Another hello
